<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>JS2-2. 바(var),렛(let),콘스트(const)</title>
    <script>

        /******************************************** 
        
            변수는 바.렛.콘스트!!!

            [ var ] : 함수영역변수

            1. 함수영역에서 사용할때만 지역변수,
            바깥쪽은 전역변수다!
            (지역변수는 함수내부에서만 사용되는 변수
            - 다른함수나 바깥영역에서는 이 변수를 모름
            / 전역변수는 함수바깥에 선언되어 어떤 함수
            에서도 그 변수를 참조하여 쓸 수 있다!)
        
            2. 전역변수와 같은 이름의 변수를 함수에서
            값을 주면 덮어쓰기가 된다!
            
            3. 함수영역에서 전역변수와 같은 이름의 변수를
            선언하면 전역변수와 다른 지역변수로 관리된다!
            (이렇게 하면 코딩이 매우 혼란스러워진다!)

            __________________________________________

            [ let ] : 블록영역변수 (중괄호는 모두 블록임!)

            1. let으로 변수를 만들면 전역과 지역을 별도로
            관리하여 같은 이름변수도 별개의 변수로 인식함!

            2. let변수는 선언 후에 아래쪽에서 사용해야
            호출할 수 있다 (var는 위에서 호출하고 아래서 선언
            할 수 있다-> 호이스팅!)

            3. 같은 영역에 같은 이름의 변수를 중복 선언할 수 없다!

            __________________________________________

            [ const ] : 상수(constant) ->  변하지 않는값

            1. 선언과 동시에 할당해야함!

            2. 한번 할당한 값은 변경불가!

            3. 배열과 객체, 함수를 상수로 만드는 경우가 많다!
            -> 변경불가는 각 배열형, 객체형, 함수형
            -> 변경가능은 각 배열값, 객체값, 함수전달값

            4. 기타의 특징은 let과 동일함(블록단위변수)


        ********************************************/

        /////////// var 테스트 /////////////////
        // JS에서 중괄호{}란? -> 코드를 묶어주는 영역

        // 함수 중괄호에서 var ///////
        function callMe(){
            // 함수내 변수는 지역변수
            var usa = "미국";

            // 함수내에서 전역변수 korea값 변경
            korea = "코리아";

            console.log(
                "함수바깥 korea를 함수내에서:",korea);

            // 전역변수 uk와 같은 이름의 지역변수를 선언하고 할당하면?
            var uk = "유케이";
            // -> 전역변수인 uk는 더이상 사용할 수 없다!ㅠ.ㅠ


            console.log(
                "함수바깥 uk를 함수내에서:",uk);
        } ////// callMe함수 /////////

        // 함수바깥에서 변수선언과 할당하기!
        var korea = "한국";
        var uk = "영국";

        // 바깥에서 korea - 함수호출전
        console.log("바깥에서 korea 함수호출전:",korea);

        // 함수호출
        callMe();

        // 바깥에서 korea - 함수호출후
        console.log("바깥에서 korea 함수호출후:",korea);

        // 바깥에서 uk - 함수호출후
        console.log("바깥에서 uk 함수호출후:",uk);

        // 함수내 지역변수 usa 찍어보기 -> 에러남!
        // console.log("함수내 usa 바깥에서 찍기:",usa);
        // Uncaught ReferenceError: usa is not defined
        // 함수 내의 지역변수는 전역에서 참조할 수 없다!

        // if문 중괄호 var ////////////////////
        if(true){
            var who = "누구?";
            console.log("if문안 who:",who);
        } ///// if /////////
        
        console.log("if문밖 who:",who);
        // if문 중괄호안에서 변수를 선언하면
        // 전역변수와 같다!

        // for문 중괄호 var ///////
        for(var i = 3; i > 0; i--){
            console.log("for문안 i:",i);
        } /////// for문 //////////
        
        console.log("for문밖 i:",i);
        // for문 중괄호안에서 변수를 선언하면
        // 전역변수와 같다!

        //->>>>> var는 오직 함수의 중괄호 안에서만 선언시
        // 지역변수로 사용된다!

        ///////////////////////////////////////////////////

        //// let, const 테스트 ////////////////
        var seoul = "서울";
        var jeju = "제주도";
        let toktok = "카톡";
        let sport = "축구";

        /// 중괄호로 블록영역을 만들어 본다! //////////

        /* **************************************** */
        {

            // 블록내부에서 전역변수 찍기! 앞
            console.log("블록내부에서 전역변수 찍기! 앞");
            console.log("seoul:",seoul);
            // console.log("jeju:",jeju); 에러남!
            // console.log("toktok:",toktok); 에러남!
            console.log("sport:",sport);

            // 블록에서 변수 재선언하기! //////
            var seoul = "강남구";
            // 전역변수가 다시 선언되어 할당된 결과임!
            
            let jeju = "마라도";
            // 전역변수 var로 선언된 같은 이름의 변수를
            // let으로 블록영역에서 선언하여 할당하면
            // 블록영역의 지역변수가 된다!
            // 이 변수보다 위에서 미리 찍을 수 없다!(에러발생)
            // -> 전역변수 jeju와의 연결이 끊어짐!

            let toktok = "라인";
            // 전역변수 let으로 선언된 같은 이름의 변수를
            // let으로 블록영역에서 선언하여 할당하면
            // 블록영역의 지역변수가 된다!(jeju와 같음)

            // var sport = "배구"; 에러남!
            // let으로 이미 전역변수에 선언된 변수는
            // 블록영역에서 var로 재선언할 수 없다!
            // 왜? var는 전역변수로 선언하는 것과 같기때문!

            myitem = "곰인형";
            // 선언없이 변수를 할당하면?
            // 기본적으로 var선언하여
            // 전역변수로 등록된 것과 같다!(함수내에서도 동일함!)
            // 편리한게 아니고 변수관리가 부실해짐!
            // 반드시 선언하고 사용할 것!

            // 블록내부에서 전역변수 찍기! 뒤
            console.log("블록내부에서 전역변수 찍기! 뒤");
            console.log("seoul:",seoul);
            console.log("jeju:",jeju); // 마라도
            console.log("toktok:",toktok); // 라인
            console.log("sport:",sport);
            console.log("myitem:",myitem);


        }
        /* **************************************** */

        // 전역에서 전역변수 찍기!
        console.log("전역에서 전역변수 찍기!");
        console.log("seoul:",seoul);
        console.log("jeju:",jeju); // 제주도
        console.log("toktok:",toktok); // 카톡
        console.log("sport:",sport);        
        console.log("myitem:",myitem);


        ////////////////////////////////////////////////

        // 변수 호이스팅(hoisting)
        cat = "고양이"; // 변수할당먼저
        console.log("cat:",cat);
        var cat; // 변수의 선언을 나중에!
        // 변수의 선언을 할당 후에 할 수 있는 것을
        // 변수 호이스팅 이라고 함!(var인 경우 사용됨!)
        // 문제는 뭐지? 코딩순서에 혼란이 야기됨!!!

        // let을 사용하면 변수 호이스팅이 금지된다!
        let dog; // 위에서 선언해야함!
        dog = "강아지";
        console.log("dog:",dog);
        // let dog;
        // 아래와 같은 에러메시지 나옴.
        // Uncaught ReferenceError: Cannot access 'dog' before initialization

        ///////////// 상수 테스트 ///////////////////
        // const fish; -> 선언을 따로하면 에러남!
        const fish = "고등어";
        console.log("상수 fish:",fish);

        // fish = "참치";
        // 상수는 재할당 불가!!!

        ///////////////////////////////////
        //////////// const의 활용 /////////
        //////////////////////////////////

        // 배열일 경우
        const myArr = ["상추","고기","마늘"];
        console.log("상수 배열 myArr 전체값:",myArr.valueOf());
        console.log("상수 배열 myArr 두번째값:",myArr[1]);

        // 배열값 추가하기
        // push() - 배열 맨뒤에 추가
        myArr.push("김치");
        console.log("상수 배열 myArr 전체값:",myArr.valueOf());

        // 배열값 변경
        // 배열주소에 값을 할당한다!
        myArr[1] = "닭고기";
        console.log("상수 배열 myArr 전체값:",myArr.valueOf());

        // 배열값 삭제1
        // shift() 메서드 - 맨앞 배열삭제
        myArr.shift();
        console.log("상수 배열 myArr 전체값:",myArr.valueOf());

        // 배열값 삭제2
        // pop() 메서드 - 맨뒤 배열삭제
        myArr.pop();
        console.log("상수 배열 myArr 전체값:",myArr.valueOf());


        ///// 객체일 경우 /////////////

        const myObj = {
            first: "나야나",
            second: "너두냐",
            third:()=>console.log("객체함수실행!")
        }; //////// myObj객체 /////////


        // 값찍기
        console.log("상수 객체 myObj 중 second값:",myObj.second);
        // 값변경
        myObj.second = "배불러~!";
        console.log("상수 객체 myObj 중 second값:",myObj.second);

        // 속성추가
        // 추가방법: Object 객체의 속성정의 메서드를 사용함
        // -> Object.defineProperty(객체명,속성명,{value:속성값})
        Object.defineProperty(myObj,"name",{value:"톰소여"});
        console.log("상수 객체 myObj 중 추가된 name값:",myObj.name);
        console.log("상수 객체 myObj:",myObj);

        // 속성지우기
        // delete 객체명.속성명 -> 속성을 삭제함!
        // myObj.second 를 삭제하자!
        delete myObj.second;
        console.log("상수 객체 myObj 중 second값:",myObj.second);
        console.log("상수 객체 myObj:",myObj);

        // 함수호출
        myObj.third();


    </script>
</head>

<body>
    
</body>
</html>